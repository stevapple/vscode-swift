//===----------------------------------------------------------------------===//
//
// This source file is part of the VSCode Swift open source project
//
// Copyright (c) 2022 the VSCode Swift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of VSCode Swift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import { readFileSync } from "fs";
import path = require("path");
import { TextEncoder } from "util";
import * as vscode from "vscode";
import { DestinationConfiguration } from "../configuration";
import { pathExists } from "../utilities/utilities";

/** build destination configuration */
export class Destination {
    constructor(
        /** Path to the configuration file */
        public path: string,
        /** Is generated by the Swift plugin */
        public generated: boolean,
        /** Path to tools directory */
        public toolchainBinDir: string,
        /** Target triple */
        public triple?: string,
        /** Path to destination SDK */
        public sdk?: string,
        /** Extra arguments to pass to Swift compiler */
        public extraSwiftCFlags: string[] = [],
        /** Extra arguments to pass to C compiler */
        public extraCCFlags: string[] = [],
        /** Extra arguments to pass to C++ compiler */
        public extraCPPFlags: string[] = []
    ) {}

    static async create(
        toolchainPath: string,
        configuration: DestinationConfiguration | string,
        storage: vscode.Uri
    ): Promise<Destination | undefined> {
        if (typeof configuration === "string") {
            return destinationFromFile(configuration);
        }
        const destinationFile = vscode.Uri.joinPath(storage, "destination.json");
        const destination = new Destination(
            destinationFile.path,
            true,
            configuration.binDir ?? path.join(toolchainPath, "usr", "bin"),
            configuration.target,
            configuration.sdk,
            configuration.extraSwiftCFlags,
            configuration.extraCCFlags,
            configuration.extraCPPFlags
        );
        await vscode.workspace.fs.writeFile(
            destinationFile,
            new TextEncoder().encode(JSON.stringify(destination))
        );
        return destination;
    }

    toJSON(): object {
        return {
            version: 1,
            triple: this.triple,
            sdk: this.sdk,
            "toolchain-bin-dir": this.toolchainBinDir,
            "extra-swiftc-flags": this.extraSwiftCFlags,
            "extra-cc-flags": this.extraCCFlags,
            "extra-cpp-flags": this.extraCPPFlags,
        };
    }

    get extraSourcekitLSPFlags(): string[] {
        const swiftFlags = this.extraSwiftCFlags;
        const cFlags = this.extraCCFlags;
        const cxxFlags = this.extraCPPFlags;
        if (this.triple) {
            swiftFlags.push("-target", this.triple);
        }
        if (this.sdk) {
            swiftFlags.push("-sdk", this.sdk);
        }
        return swiftFlags
            .flatMap(flag => ["-Xswiftc", flag])
            .concat(cFlags.flatMap(flag => ["-Xcc", flag]))
            .concat(cxxFlags.flatMap(flag => ["-Xcxx", flag]));
    }

    get extraSwiftPMFlags(): string[] {
        return this.path ? ["--destination", this.path] : [];
    }
}

function destinationFromFile(path: string): Destination | undefined {
    if (path === "" || !pathExists(path)) {
        return undefined;
    }
    const buffer = readFileSync(path);
    const destination = JSON.parse(buffer.toString("utf8"));
    if (destination.version !== 1) {
        return undefined;
    }
    return new Destination(
        path,
        false,
        destination["toolchain-bin-dir"],
        destination["triple"],
        destination["sdk"],
        destination["extra-swiftc-flags"],
        destination["extra-cc-flags"],
        destination["extra-cpp-flags"]
    );
}
